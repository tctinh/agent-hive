/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: scripts/generate-skills.ts
 * Run: bun run scripts/generate-skills.ts
 */

import type { SkillDefinition } from './types.js';

/**
 * List of builtin skill names.
 */
export const BUILTIN_SKILL_NAMES = ["hive", "hive-execution"] as const;

/**
 * All builtin skill definitions.
 */
export const BUILTIN_SKILLS: SkillDefinition[] = [
  {
    name: "hive",
    description: "Plan-first AI development with isolated git worktrees and human review. Use for any feature development.",
    template: "# Hive Workflow\n\nYou are working in a Hive-enabled repository. Follow this plan-first workflow.\n\n## Lifecycle\n\n```\nFeature -> Plan -> Review -> Approve -> Execute -> Merge -> Complete\n```\n\n---\n\n## Phase 1: Planning\n\n### Start Feature\n\n```\nhive_feature_create({ name: \"feature-name\" })\n```\n\n### Research First\n\nBefore writing anything:\n1. Search for relevant files (grep, explore)\n2. Read existing implementations\n3. Identify patterns and conventions\n\nSave all findings:\n```\nhive_context_write({\n  name: \"research\",\n  content: `# Research Findings\n\n## Existing Patterns\n- Theme system uses CSS variables in src/theme/\n- Components follow atomic design\n\n## Files to Modify\n- src/theme/colors.ts\n- src/components/ThemeProvider.tsx\n`\n})\n```\n\n### Write the Plan\n\nFormat for task parsing:\n\n```markdown\n# Feature Name\n\n## Overview\nOne paragraph explaining what and why.\n\n## Tasks\n\n### 1. Task Name\nDescription of what this task accomplishes.\n- Specific files to modify\n- Expected outcome\n\n### 2. Another Task\nDescription...\n\n### 3. Final Task\nDescription...\n```\n\nWrite with:\n```\nhive_plan_write({ content: `...` })\n```\n\n**STOP** and tell user: \"Plan written. Please review.\"\n\n---\n\n## Phase 2: Review (Human)\n\n- User reviews plan.md in VS Code sidebar\n- User can add comments\n- Use `hive_plan_read()` to see user comments\n- Revise plan based on feedback\n- User clicks \"Approve\" or runs `hive_plan_approve()`\n\n---\n\n## Phase 3: Execution\n\n### Generate Tasks\n\n```\nhive_tasks_sync()\n```\n\nParses `### N. Task Name` headers into task folders.\n\n### Execute Each Task\n\nFor each task in order:\n\n#### 1. Start (creates worktree)\n```\nhive_exec_start({ task: \"01-task-name\" })\n```\n\n#### 2. Implement\nWork in the isolated worktree path. Read `spec.md` for context.\n\n#### 3. Complete (commits to branch)\n```\nhive_exec_complete({ task: \"01-task-name\", summary: \"What was done\" })\n```\n\n#### 4. Merge (integrates to main)\n```\nhive_merge({ task: \"01-task-name\", strategy: \"squash\" })\n```\n\n---\n\n## Phase 4: Completion\n\nAfter all tasks merged:\n```\nhive_feature_complete({ name: \"feature-name\" })\n```\n\n---\n\n## Tool Quick Reference\n\n| Phase | Tool | Purpose |\n|-------|------|---------|\n| Plan | `hive_feature_create` | Start new feature |\n| Plan | `hive_context_write` | Save research findings |\n| Plan | `hive_plan_write` | Write the plan |\n| Plan | `hive_plan_read` | Check for user comments |\n| Plan | `hive_plan_approve` | Approve plan |\n| Execute | `hive_tasks_sync` | Generate tasks from plan |\n| Execute | `hive_exec_start` | Start task (creates worktree) |\n| Execute | `hive_exec_complete` | Finish task (commits changes) |\n| Execute | `hive_merge` | Integrate task to main |\n| Complete | `hive_feature_complete` | Mark feature done |\n\n---\n\n## Task Design Guidelines\n\n### Good Tasks\n\n| Characteristic | Example |\n|---------------|---------|\n| **Atomic** | \"Add ThemeContext provider\" not \"Add theming\" |\n| **Testable** | \"Toggle switches between light/dark\" |\n| **Independent** | Can be completed without other tasks (where possible) |\n| **Ordered** | Dependencies come first |\n\n### Task Sizing\n\n- **Too small**: \"Add import statement\" - combine with related work\n- **Too large**: \"Implement entire feature\" - break into logical units\n- **Just right**: \"Create theme context with light/dark values\"\n\n---\n\n## Rules\n\n1. **Never skip planning** - Always write plan first\n2. **Context is critical** - Save all research with `hive_context_write`\n3. **Wait for approval** - Don't execute until user approves\n4. **One task at a time** - Complete and merge before starting next\n5. **Squash merges** - Keep history clean with single commit per task\n\n---\n\n## Error Recovery\n\n### Task Failed\n```\nhive_exec_abort(task=\"<task>\")  # Discards changes\nhive_exec_start(task=\"<task>\")  # Fresh start\n```\n\n### Merge Conflicts\n1. Resolve conflicts in the worktree\n2. Commit the resolution\n3. Run `hive_merge` again\n\n---\n\n## Example\n\nUser: \"Add dark mode support\"\n\n```\n1. hive_feature_create({ name: \"dark-mode\" })\n2. Research: grep for theme, colors, CSS variables\n3. hive_context_write({ name: \"research\", content: \"Found theme in src/theme/...\" })\n4. hive_plan_write({ content: \"# Dark Mode\\n\\n## Tasks\\n\\n### 1. Add theme context...\" })\n5. Tell user: \"Plan ready for review\"\n6. [User reviews and approves]\n7. hive_tasks_sync()\n8. For each task: exec_start -> implement -> exec_complete -> merge\n9. hive_feature_complete({ name: \"dark-mode\" })\n```",
  },
  {
    name: "hive-execution",
    description: "Execute Hive feature tasks with worktree isolation, parallel orchestration, and clean git history. Use when running synced Hive tasks.",
    template: "# Hive Execution Orchestration\n\nExecute Hive feature tasks with worktree isolation and clean git history. Supports both sequential (single executor) and parallel (multiple executors) workflows.\n\n## When to Use This Skill\n\n- Executing a Hive feature with synced tasks\n- Managing worktree lifecycle (create, work, merge, cleanup)\n- Ensuring single-commit-per-task on main branch\n- Optionally: Running tasks in parallel when multiple executors are available\n\n## Pre-Execution Checklist\n\nBefore starting execution, verify:\n\n1. **Feature exists**: `hive_feature_list` shows target feature\n2. **Plan approved**: Feature status is `approved` or `executing`\n3. **Tasks synced**: `hive_session_open(feature)` shows task list\n4. **Base branch clean**: No uncommitted changes in main worktree\n\n## Execution Models\n\n### Sequential Execution (Single Executor)\n\nWhen running with a single executor, process tasks in order:\n\n```\nTask 01 → complete → merge\nTask 02 → complete → merge\nTask 03 → complete → merge\n...\n```\n\nFollow task numbering order unless dependencies require otherwise.\n\n### Parallel Execution (Multiple Executors - Optional)\n\nIf your environment supports multiple parallel executors, tasks can be organized into **phases** based on dependencies:\n\n```\nPhase 0 (start immediately, parallel):\n  - Executor A: Task that creates shared infrastructure (BLOCKER)\n  - Executor B: Independent task (no dependencies)\n  - Executor C: Independent task (no dependencies)\n\nPhase 1 (after Phase 0 blockers merged, parallel):\n  - Executor A: Task depending on Phase 0 blocker\n  - Executor B: Another dependent task\n  - Executor C: Another dependent task\n\nPhase 2 (final gate):\n  - Any executor: Verification/integration task\n```\n\n### Dependency Rules\n\nWhen determining execution order (sequential or parallel):\n\n| Dependency Type | Action |\n|-----------------|--------|\n| **Blocker task** | Must be merged before dependents start |\n| **Shared files** | Tasks touching same files = sequential |\n| **Independent** | Can run in parallel (if supported) or in any order |\n\n## Task Execution Lifecycle\n\nFor EACH task, follow this exact sequence:\n\n### 1. Start Task (creates isolated worktree)\n\n```\nhive_exec_start(task=\"<task-folder-name>\")\n```\n\nThis:\n- Creates a git worktree from current base branch\n- Sets task status to `in_progress`\n- Generates `spec.md` with context from completed tasks\n\n### 2. Implement in Worktree\n\nWork ONLY within the task's worktree directory. The worktree path is returned by `hive_exec_start`.\n\n- Read `spec.md` for task context and acceptance criteria\n- Implement changes\n- Verify against acceptance criteria\n- Run tests/build if applicable\n\n### 3. Complete Task (commits to task branch)\n\n```\nhive_exec_complete(task=\"<task-folder-name>\", summary=\"<what-was-done>\")\n```\n\nThis:\n- Commits all changes to the task branch\n- Generates `report.md` with diff stats\n- Sets task status to `done`\n- **Does NOT merge** - worktree preserved\n\n### 4. Merge to Main (squash for clean history)\n\n```\nhive_merge(task=\"<task-folder-name>\", strategy=\"squash\")\n```\n\nThis:\n- Squash-merges task branch into current branch\n- Results in exactly ONE commit per task on main\n- Commit message follows format: `hive(<task>): <summary>`\n\n### 5. Cleanup (optional, recommended)\n\nAfter successful merge, the worktree can be removed via git:\n\n```bash\ngit worktree remove .hive/worktrees/<feature>/<task>\ngit branch -d hive/<feature>/<task>\n```\n\n## Scheduling Strategy\n\n### Single Executor (Default)\n\nExecute tasks sequentially in numerical order:\n\n```\n1. hive_exec_start → implement → hive_exec_complete → hive_merge\n2. Move to next task\n3. Repeat until all tasks done\n```\n\nRespect dependencies: if Task 05 depends on Task 02, ensure Task 02 is merged before starting Task 05.\n\n### Multiple Executors (Optional Optimization)\n\nIf your environment supports parallel execution (e.g., multiple agent sessions, CI runners, or orchestration tools):\n\n1. **Identify blockers**: Tasks that create shared resources others depend on\n2. **Group by phase**: Tasks that can run in parallel within each phase\n3. **Assign to executors**: Balance workload across available executors\n4. **Minimize conflicts**: Avoid assigning tasks touching same files to same phase\n\n#### Example Schedule (3 Executors)\n\n```markdown\n## Scheduling (3 executors)\n\n### Phase 0 (start immediately, parallel)\n- Executor A: 02-create-shared-helpers (BLOCKER - others depend on this)\n- Executor B: 01-update-documentation (independent)  \n- Executor C: 08-fix-config-issue (independent)\n\n### Phase 1 (after Task 02 merged, parallel)\n- Executor A: 06-feature-using-helpers, then 03-another-feature\n- Executor B: 04-related-feature\n- Executor C: 07-different-feature\n\n### Phase 2 (final gate)\n- Any executor: 09-final-verification\n```\n\n> **Note**: Parallel execution is an optimization. The same tasks can always be executed sequentially by a single executor.\n\n## Tool Quick Reference\n\n| Phase | Tool | Purpose |\n|-------|------|---------|\n| Start | `hive_exec_start(task)` | Create worktree, begin work |\n| Work | `hive_subtask_create(task, name, type)` | Break into TDD subtasks |\n| Progress | `hive_subtask_update(task, subtask, status)` | Track subtask completion |\n| Complete | `hive_exec_complete(task, summary)` | Commit changes to branch |\n| Integrate | `hive_merge(task, strategy=\"squash\")` | Merge to main with single commit |\n| Abort | `hive_exec_abort(task)` | Discard changes, reset status |\n| Status | `hive_worktree_list()` | See all active worktrees |\n\n## Commit Discipline\n\n### Requirements\n\n- **One commit per task on main**: Use `hive_merge(strategy=\"squash\")`\n- **Meaningful message**: Reflect the \"why\" not just \"what\"\n- **Follow conventions**: Check repo's existing commit style\n\n### Commit Message Format\n\n```\nhive(<task-folder>): <concise summary of change>\n\n<optional body explaining why this change was needed>\n```\n\n## Error Recovery\n\n### Task Failed Mid-Execution\n\n```\nhive_exec_abort(task=\"<task>\")  # Discards changes, resets to pending\nhive_exec_start(task=\"<task>\")  # Fresh start\n```\n\n### Merge Conflicts\n\nIf `hive_merge` reports conflicts:\n\n1. Resolve conflicts in the worktree\n2. Commit the resolution\n3. Run `hive_merge` again OR merge manually\n\n### Blocker Task Failed\n\nIf a Phase 0 blocker fails:\n\n1. Do NOT start Phase 1 tasks\n2. Fix the blocker\n3. Complete and merge blocker\n4. THEN start Phase 1\n\n## Verification Gate\n\nBefore marking feature complete:\n\n- [ ] All tasks show status `done`\n- [ ] All task branches merged to main\n- [ ] No orphaned worktrees (`hive_worktree_list` empty or cleaned)\n- [ ] Final verification task passed\n- [ ] Build passes on main branch\n\n## Example: Full Execution Flow\n\n### Sequential (Single Executor)\n\n```\n# 1. Open session to see current state\nhive_session_open(feature=\"my-feature\")\n\n# 2. Execute tasks in order\nhive_exec_start(task=\"01-first-task\")\n# ... implement ...\nhive_exec_complete(task=\"01-first-task\", summary=\"Completed first task\")\nhive_merge(task=\"01-first-task\", strategy=\"squash\")\n\nhive_exec_start(task=\"02-second-task\")\n# ... implement ...\nhive_exec_complete(task=\"02-second-task\", summary=\"Completed second task\")\nhive_merge(task=\"02-second-task\", strategy=\"squash\")\n\n# Continue for remaining tasks...\n\n# 3. Complete feature\nhive_feature_complete(feature=\"my-feature\")\n```\n\n### Parallel (Multiple Executors - Optional)\n\n```\n# 1. Open session to see current state\nhive_session_open(feature=\"my-feature\")\n\n# 2. Phase 0 - Start parallel tasks\n# Executor A:\nhive_exec_start(task=\"02-shared-helpers\")\n# ... implement ...\nhive_exec_complete(task=\"02-shared-helpers\", summary=\"Added shared test helpers module\")\nhive_merge(task=\"02-shared-helpers\", strategy=\"squash\")\n\n# Executor B (parallel):\nhive_exec_start(task=\"01-update-docs\")\n# ... implement ...\nhive_exec_complete(task=\"01-update-docs\", summary=\"Updated README with new metrics\")\nhive_merge(task=\"01-update-docs\", strategy=\"squash\")\n\n# 3. Phase 1 - After blocker merged\n# Executor A:\nhive_exec_start(task=\"06-use-helpers\")\n# ... implement using the helpers from task 02 ...\nhive_exec_complete(task=\"06-use-helpers\", summary=\"Integrated shared helpers in tests\")\nhive_merge(task=\"06-use-helpers\", strategy=\"squash\")\n\n# 4. Final verification\nhive_exec_start(task=\"09-final-check\")\n# ... run full test suite, verify everything works ...\nhive_exec_complete(task=\"09-final-check\", summary=\"All tests pass, CI green\")\nhive_merge(task=\"09-final-check\", strategy=\"squash\")\n\n# 5. Complete feature\nhive_feature_complete(feature=\"my-feature\")\n```",
  }
];
